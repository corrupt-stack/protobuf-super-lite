// Copyright 2022 Yuri Wiitala. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>
#include <ostream>
#include <string>
#include <type_traits>
#include <vector>

#include "pb/codec/zigzag.h"
#include "pb/integer_wrapper.h"

namespace pb {

class BytesSpan;
class FieldSpan;
class FixedNN;
class MessageSpan;
class VarintSpan;
class WireSpan;

// Scans the given range, producing an interpretation of probable protobuf
// fields. If |permissive| is true, the scan will separately produce ranges of
// non-protobuf bytes and possible protobuf message fields found in the buffer.
// If |permissive| is false, the buffer must be exactly parseable as a sequence
// of protobuf message fields; otherwise, an empty vector is returned.
//
// After the scan, human-readable text output can be generated by calling
// InspectionRenderingContext::Print() on the result, or on individual WireSpan
// objects (using WireSpan::MakeInspection()) in the resulting vector.
std::vector<std::unique_ptr<WireSpan>>
ScanForMessageFields(const uint8_t* begin, const uint8_t* end, bool permissive);

// Returns a MessageSpan if the given range of bytes can be interpreted as a
// protobuf message. Otherwise, returns nullptr.
//
// The interpretation may be inexact. It is a best-effort reconstruction.
std::unique_ptr<MessageSpan> ParseProbableMessage(const uint8_t* begin,
                                                  const uint8_t* end);

// Configuration parametrs and state used to render the inspection text.
struct InspectionRenderingContext {
  InspectionRenderingContext(const uint8_t* buffer_begin,
                             std::ptrdiff_t max_bytes = 1 << 11,
                             std::ptrdiff_t bytes_per_line = 16);

  // Returns a default rendering context for inspection all of the |spans| as a
  // combined unit. The rendering context is configured to limit output to the
  // first 2 KB of wire data, and print 16 bytes per line.
  static InspectionRenderingContext MakeDefaultFor(
      const std::vector<std::unique_ptr<WireSpan>>& spans);

  // Pointer corresponding to the first byte (index offset 0).
  const uint8_t* const offset_zero;

  // Pointer limiting the amount of inspection text being generated. Stops
  // generating text once this point is reached.
  const uint8_t* const limit;

  // Number of wire bytes per line of text.
  const std::ptrdiff_t bytes_per_line;

  // Current string of whitespace and line art to place between the hex dump on
  // the left and the interpretation of the bytes on the right.
  std::string indentation{' ', ' '};

  // Returns the byte-offset of the start of the row containing
  // |some_byte_in_the_row|.
  std::ptrdiff_t ComputeRowIndexOffset(
      const uint8_t* some_byte_in_the_row) const;

  // Returns a specific row of human-readable hex-dump output, but with any
  // bytes not in the given range spaced-out. Example:
  //
  //   00000028  80 1F 23 55 AA 9C 7F 00
  //
  // Example, where leading bytes are missing from the range:
  //
  //   000000E0                 20 65 0A
  std::string MakeHexDumpRow(std::ptrdiff_t row_offset,
                             const uint8_t* begin,
                             const uint8_t* end) const;

  // Returns human-readable hex-dump output for any rows that contain bytes in
  // the given range. If no rows contain bytes in the given range, an empty
  // vector is returned.
  std::vector<std::string> MakeHexDumpRows(const uint8_t* begin,
                                           const uint8_t* end) const;

  // Prints the result of calling WireSpan::MakeInspection() on each of the
  // given |spans| to |utf8_out|. The output is UTF-8 encoded string data.
  void Print(const std::vector<std::unique_ptr<WireSpan>>& spans,
             std::ostream& utf8_out);
};

// Base class representing a span of wire bytes. If the bytes represent a
// protobuf field, AsFieldSpan() will return non-null.
class WireSpan {
 public:
  WireSpan(const uint8_t* begin, const uint8_t* end);

  virtual ~WireSpan();

  const uint8_t* begin() const { return begin_; }
  const uint8_t* end() const { return end_; }

  virtual FieldSpan* AsFieldSpan();

  // Returns lines of text comprising a hex dump of the wire bytes, plus a
  // human-readable interpretation of what the bytes represent.
  virtual std::vector<std::string> MakeInspection(
      InspectionRenderingContext& context) const;

 protected:
  // Prints the 8-bit ASCII |ch| to |utf8_out| after mapping it to something
  // human-readable, mostly using the displayed symbols from DOS code page 437
  // for control codes and upper ASCII.
  static void PrintCodePage437CharForInspection(uint8_t ch,
                                                std::ostream& utf8_out);

  // Calls PrintCodePage437CharForInspection() for each byte in the given range.
  static void PrintBytesForInspection(const uint8_t* begin,
                                      const uint8_t* end,
                                      std::ostream& utf8_out);

 private:
  const uint8_t* const begin_;
  const uint8_t* const end_;
};

// Base class representing a span of wire bytes that has been interpreted as a
// protobuf field (field number plus value).
class FieldSpan : public WireSpan {
 public:
  ~FieldSpan() override;

  int32_t field_number() const { return field_number_; }

  FieldSpan* AsFieldSpan() final;

  virtual BytesSpan* AsBytesSpan();
  virtual MessageSpan* AsMessageSpan();

 protected:
  FieldSpan(const uint8_t* begin, const uint8_t* end, int32_t field_number);

  // Prints "[N] = " replacing N with the field number for this field.
  void PrintInterpretationLeftHandSide(std::ostream& utf8_out) const;

 private:
  const int32_t field_number_;
};

// A span of wire bytes that represent a varint field.
class VarintSpan final : public FieldSpan {
 public:
  VarintSpan(const uint8_t* begin,
             const uint8_t* end,
             int32_t field_number,
             uint64_t value);

  ~VarintSpan() final;

  // The wire bytes do not indicate whether the varint is unsigned, signed, or
  // zig-zag encoded; and thus, there are three accessors for providing each
  // possible interpretation.
  uint64_t as_unsigned() const { return value_; }
  int64_t as_signed() const { return static_cast<int64_t>(value_); }
  ::pb::sint64_t as_zigzag() const { return codec::DecodeZigZag(value_); }

  std::vector<std::string> MakeInspection(
      InspectionRenderingContext& context) const override;

 private:
  const uint64_t value_;
};

// A span of wire bytes that represent a string field.
class BytesSpan final : public FieldSpan {
 public:
  BytesSpan(const uint8_t* begin,
            const uint8_t* end,
            int32_t field_number,
            const uint8_t* bytes_begin);

  ~BytesSpan() final;

  bool is_utf8_string() const { return utf8_char_count_ > 0; }
  std::ptrdiff_t utf8_char_count() const { return utf8_char_count_; }

  // Non-copy accessors to the bytes.
  const uint8_t* bytes_begin() const { return bytes_begin_; }
  const uint8_t* bytes_end() const { return end(); }

  // Returns a copy of the bytes in a std::string.
  std::string MakeString() const;

  std::vector<std::string> MakeInspection(
      InspectionRenderingContext& context) const override;

 protected:
  BytesSpan* AsBytesSpan() final;

 private:
  // Returns the number of UTF-8-encoded characters in the given buffer. If the
  // buffer does not contain a valid UTF-8 string, a negative number is
  // returned.
  static std::ptrdiff_t ComputeUtf8CharacterCount(const uint8_t* begin,
                                                  const uint8_t* end);

  // Prints the UTF-8 encoded bytes, starting at |begin|, to |utf8_out| with
  // modifications that make the result useful for inspection purposes. If
  // |begin| points to anything but the first byte of a multi-byte character,
  // that character will be skipped-over. |soft_end| points to a byte within, or
  // just after, the last encoded character to print.
  //
  // WARNING: The input range MUST start at the beginning, or in the middle of,
  // a valid UTF-8 string. Otherwise, out-of-bounds memory access could occur.
  static void PrintUtf8ForInspection_Unsafe(const uint8_t* begin,
                                            const uint8_t* soft_end,
                                            std::ostream& utf8_out);

  const uint8_t* const bytes_begin_;
  const std::ptrdiff_t utf8_char_count_;
};

// A span of wire bytes that represent a protobuf message.
class MessageSpan final : public FieldSpan {
 public:
  MessageSpan(const uint8_t* begin,
              const uint8_t* end,
              int32_t field_number,
              std::vector<std::unique_ptr<FieldSpan>> message_fields);

  ~MessageSpan() final;

  const std::vector<std::unique_ptr<FieldSpan>>& fields() const {
    return fields_;
  }

  std::vector<std::string> MakeInspection(
      InspectionRenderingContext& context) const override;

 protected:
  MessageSpan* AsMessageSpan() final;

 private:
  const std::vector<std::unique_ptr<FieldSpan>> fields_;
};

// A span of wire bytes that represent a fixed64/double field.
class Fixed64 final : public FieldSpan {
 public:
  Fixed64(const uint8_t* begin,
          const uint8_t* end,
          int32_t field_number,
          fixed64_t value);

  ~Fixed64() final;

  // The wire bytes do not indicate whether the 64-bit value is floating-point,
  // an unsigned integer, or a signed integer. Thus, there are several accessors
  // for providing each possible interpretation.
  double AsDouble() const;
  ::pb::fixed64_t AsFixed64() const;
  ::pb::sfixed64_t AsSignedFixed64() const;

  std::vector<std::string> MakeInspection(
      InspectionRenderingContext& context) const override;

 private:
  const ::pb::fixed64_t value_;
};

// A span of wire bytes that represent a fixed32/float field.
class Fixed32 final : public FieldSpan {
 public:
  Fixed32(const uint8_t* begin,
          const uint8_t* end,
          int32_t field_number,
          fixed32_t value);

  ~Fixed32() final;

  // The wire bytes do not indicate whether the 64-bit or 32-bit value is
  // floating-point, an unsigned integer, or a signed integer. Thus, there are
  // several accessors for providing each possible interpretation.
  float AsFloat() const;
  ::pb::fixed32_t AsFixed32() const;
  ::pb::sfixed32_t AsSignedFixed32() const;

  std::vector<std::string> MakeInspection(
      InspectionRenderingContext& context) const override;

 private:
  const ::pb::fixed32_t value_;
};

}  // namespace pb
